<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#f8f9fa">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Bel met Craby ü¶Ä</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    /* Call-specific overrides */
    .call-page {
      overflow: hidden;
    }
    
    .phone-container {
      width: 100%;
      max-width: 400px;
      text-align: center;
      padding: 0 20px;
    }
    
    /* Avatar states */
    .call-avatar.ringing {
      animation: ring-pulse 0.5s infinite;
    }
    
    .call-avatar.connected {
      border-color: var(--success-color);
    }
    
    .call-avatar.connected::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 50%;
      border: 2px solid var(--success-color);
      opacity: 0.5;
    }
    
    @keyframes ring-pulse {
      0%, 100% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.03) rotate(-2deg); }
      75% { transform: scale(1.03) rotate(2deg); }
    }
    
    /* Call info */
    .call-info {
      margin-top: 24px;
    }
    
    .call-info .name {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    
    .call-info .type {
      color: var(--text-secondary);
      font-size: 1rem;
      margin-top: 4px;
    }
    
    /* Timer */
    .call-timer {
      font-size: 1.6rem;
      font-weight: 300;
      color: var(--success-color);
      margin: 20px 0;
      font-variant-numeric: tabular-nums;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .call-timer.visible {
      opacity: 1;
    }
    
    /* Status */
    .status-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      min-height: 32px;
    }
    
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--success-color);
      animation: blink 1.5s infinite;
    }
    
    .status-dot.listening { background: var(--success-color); }
    .status-dot.processing { background: var(--accent); animation: pulse-fast 0.5s infinite; }
    .status-dot.speaking { background: var(--accent); }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    
    @keyframes pulse-fast {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.4); opacity: 0.6; }
    }
    
    .status-text {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
    
    /* Visualizer - more compact */
    .visualizer-container {
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 12px 0;
    }
    
    .visualizer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      height: 60px;
    }
    
    .visualizer .bar {
      width: 5px;
      background: var(--accent);
      border-radius: 3px;
      transition: height 0.05s ease;
      min-height: 4px;
      opacity: 0.6;
    }
    
    .visualizer .bar.speaking-bar {
      background: var(--accent);
      opacity: 1;
    }
    
    /* Transcript - hidden when empty */
    .transcript-container:empty {
      display: none;
    }
    
    /* Speed slider - compact */
    .speed-control {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 12px 0;
      padding: 10px 16px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 14px;
      font-size: 0.85rem;
    }
    
    .speed-label {
      font-size: 0.85rem;
      color: var(--text-secondary);
      min-width: 50px;
    }
    
    .speed-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 120px;
      height: 6px;
      border-radius: 3px;
      background: var(--glass-border);
      outline: none;
      cursor: pointer;
    }
    
    .speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: transform 0.15s ease;
    }
    
    .speed-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
    }
    
    .speed-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: none;
    }
    
    .speed-value {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--accent);
      min-width: 45px;
      text-align: right;
    }
    
    .transcript-container {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 20px;
      padding: 16px;
      margin: 24px 0;
      max-height: 160px;
      overflow-y: auto;
      text-align: left;
    }
    
    .transcript-message {
      margin: 10px 0;
      padding: 12px 16px;
      border-radius: 14px;
      font-size: 0.9rem;
      line-height: 1.5;
      animation: message-in 0.3s ease;
    }
    
    .transcript-message.user {
      background: var(--message-user-bg);
      color: var(--message-user-text);
      margin-left: 15%;
      border-bottom-right-radius: 4px;
    }
    
    .transcript-message.assistant {
      background: var(--message-bot-bg);
      color: var(--message-bot-text);
      border: 1px solid var(--glass-border);
      margin-right: 15%;
      border-bottom-left-radius: 4px;
    }
    
    .transcript-message .label {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 4px;
      font-weight: 500;
    }
    
    /* Call buttons - Now positioned higher */
    .call-actions {
      display: flex;
      justify-content: center;
      gap: 24px;
      margin-top: 24px;
      margin-bottom: 16px;
    }
    
    .call-btn {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: none;
      font-size: 1.6rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
    }
    
    .call-btn:hover {
      transform: scale(1.08);
    }
    
    .call-btn:active {
      transform: scale(0.95);
    }
    
    .btn-answer {
      background: var(--success-color);
      border-color: var(--success-color);
      box-shadow: 0 8px 24px rgba(56, 161, 105, 0.35);
    }
    
    .btn-answer:hover {
      box-shadow: 0 12px 32px rgba(56, 161, 105, 0.5);
    }
    
    .btn-hangup {
      background: var(--recording-color);
      border-color: var(--recording-color);
      box-shadow: 0 8px 24px rgba(229, 62, 62, 0.35);
    }
    
    .btn-hangup:hover {
      box-shadow: 0 12px 32px rgba(229, 62, 62, 0.5);
    }
    
    .btn-mute.muted {
      background: var(--recording-color);
      border-color: var(--recording-color);
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: opacity 0.5s;
    }
    
    .loading-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--glass-border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .loading-text {
      margin-top: 20px;
      color: var(--text-secondary);
    }
    
    /* Back button */
    .back-button {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: none;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      transition: all 0.2s ease;
      box-shadow: var(--glass-shadow);
      z-index: 50;
    }
    
    .back-button:hover {
      transform: scale(1.1);
    }
    
    /* Safe area for bottom controls */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .call-actions {
        padding-bottom: calc(20px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body class="call-page">
  <!-- Theme Toggle -->
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
    <span class="icon-moon">üåô</span>
    <span class="icon-sun">‚òÄÔ∏è</span>
  </button>
  
  <!-- Back button -->
  <button class="back-button" onclick="window.location='/'">‚Üê</button>
  
  <!-- Loading overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <p class="loading-text">VAD model laden...</p>
  </div>
  
  <!-- Error banner -->
  <div class="error" id="errorBanner"></div>
  
  <main class="call-page">
    <div class="phone-container">
      <!-- Avatar -->
      <div class="call-avatar" id="avatar">ü¶Ä</div>
      
      <div class="call-info">
        <h1 class="name">Craby</h1>
        <p class="type" id="callType">Tik om te bellen</p>
      </div>
      
      <!-- Timer -->
      <div class="call-timer" id="callTimer">00:00</div>
      
      <!-- Status -->
      <div class="status-indicator" id="statusIndicator">
        <div class="status-dot" id="statusDot"></div>
        <span class="status-text" id="statusText">Klaar om te bellen</span>
      </div>
      
      <!-- Visualizer -->
      <div class="visualizer-container">
        <div class="visualizer" id="visualizer">
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
          <div class="bar"></div>
        </div>
      </div>
      
      <!-- Call buttons - Start (moved up for visibility) -->
      <div class="call-actions" id="callActions">
        <button class="call-btn btn-answer" id="btnCall" title="Bel">üìû</button>
      </div>
      
      <!-- Call buttons - In Call -->
      <div class="call-actions hidden" id="inCallActions">
        <button class="call-btn btn-mute" id="btnMute" title="Mute">üé§</button>
        <button class="call-btn btn-hangup" id="btnHangup" title="Ophangen">üìµ</button>
      </div>
      
      <!-- Transcript (shown during call) -->
      <div class="transcript-container" id="transcript"></div>
      
      <!-- Speed slider (at bottom) -->
      <div class="speed-control">
        <span class="speed-label">Snelheid</span>
        <input type="range" class="speed-slider" id="speedSlider" 
               min="0.5" max="2" step="0.05" value="1.25">
        <span class="speed-value" id="speedValue">1.25x</span>
      </div>
    </div>
  </main>
  
  <!-- Audio elements -->
  <audio id="audioPlayer"></audio>
  <audio id="holdMusic" loop></audio>
  <audio id="ringTone" loop>
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2JkZiZlI2Df3d0eYKOm6SqsK+pnpCCdGtncHyKmqexu7+6saSXiXpva2x0gI6frLe/wLmvpJiLfXFrbHF7iJimsLu+ubCkl4p8cGtsdH+Ll6OvuLy3rqOWiXxyb3J5goqTnaasrauon5aOhoB8enl6fICFiouLiYaCfnt5eXp7fH5/f39+fXx7enp5eXl5eXl5eXl5eXl5eXl5eXl5eXl5" type="audio/wav">
  </audio>
  
  <!-- VAD Library (Silero VAD - high quality voice detection) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/ort.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.7/dist/bundle.min.js"></script>
  
  <script>
    // ==========================================
    // Theme management
    // ==========================================
    const themeToggle = document.getElementById('themeToggle');
    const html = document.documentElement;
    
    function getPreferredTheme() {
      const saved = localStorage.getItem('theme');
      if (saved) return saved;
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    function setTheme(theme) {
      html.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      const metaTheme = document.querySelector('meta[name="theme-color"]');
      if (metaTheme) {
        metaTheme.content = theme === 'dark' ? '#0a0a0f' : '#f8f9fa';
      }
    }
    
    setTheme(getPreferredTheme());
    
    themeToggle.addEventListener('click', () => {
      const current = html.getAttribute('data-theme');
      setTheme(current === 'dark' ? 'light' : 'dark');
    });
    
    // ==========================================
    // Call Logic (unchanged)
    // ==========================================
    
    // Elements
    const avatar = document.getElementById('avatar');
    const callType = document.getElementById('callType');
    const callTimer = document.getElementById('callTimer');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const visualizer = document.getElementById('visualizer');
    const bars = visualizer.querySelectorAll('.bar');
    const transcript = document.getElementById('transcript');
    const audioPlayer = document.getElementById('audioPlayer');
    const holdMusic = document.getElementById('holdMusic');
    const ringTone = document.getElementById('ringTone');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const errorBanner = document.getElementById('errorBanner');
    
    const btnCall = document.getElementById('btnCall');
    const btnMute = document.getElementById('btnMute');
    const btnHangup = document.getElementById('btnHangup');
    const callActions = document.getElementById('callActions');
    const inCallActions = document.getElementById('inCallActions');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    
    // ==========================================
    // Playback speed control
    // ==========================================
    
    // Load saved speed or default to 1.25
    const savedSpeed = parseFloat(localStorage.getItem('callPlaybackSpeed')) || 1.25;
    speedSlider.value = savedSpeed;
    speedValue.textContent = savedSpeed.toFixed(2) + 'x';
    audioPlayer.playbackRate = savedSpeed;
    
    speedSlider.addEventListener('input', () => {
      const speed = parseFloat(speedSlider.value);
      speedValue.textContent = speed.toFixed(2) + 'x';
      audioPlayer.playbackRate = speed;
      localStorage.setItem('callPlaybackSpeed', speed);
    });
    
    // State
    let ws = null;
    let vadInstance = null;
    let isInCall = false;
    let isMuted = false;
    let isProcessing = false;
    let isCrabySpeaking = false;
    let callStartTime = null;
    let timerInterval = null;
    let audioContext = null;
    let analyser = null;
    let audioQueue = [];
    let isPlayingQueue = false;
    let isHoldMusicPlaying = false;
    
    // Show error
    function showError(msg) {
      errorBanner.textContent = msg;
      errorBanner.classList.add('visible');
      setTimeout(() => errorBanner.classList.remove('visible'), 5000);
    }
    
    // Update status
    function setStatus(text, type = 'listening') {
      statusText.textContent = text;
      statusDot.className = 'status-dot ' + type;
    }
    
    // Update timer
    function updateTimer() {
      if (!callStartTime) return;
      const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      callTimer.textContent = `${mins}:${secs}`;
    }
    
    // Update visualizer
    function updateVisualizer(volumes, isSpeaking = false) {
      bars.forEach((bar, i) => {
        const vol = volumes[i % volumes.length] || 0;
        const height = Math.max(4, vol * 50);
        bar.style.height = height + 'px';
        bar.className = 'bar' + (isSpeaking ? ' speaking-bar' : '');
      });
    }
    
    // Add transcript message
    function addMessage(who, text) {
      const div = document.createElement('div');
      div.className = 'transcript-message ' + (who === 'user' ? 'user' : 'assistant');
      div.innerHTML = `<div class="label">${who === 'user' ? 'Jij' : 'Craby'}</div>${text}`;
      transcript.appendChild(div);
      transcript.scrollTop = transcript.scrollHeight;
    }
    
    // Connect WebSocket
    function connectWS() {
      return new Promise((resolve, reject) => {
        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${protocol}//${location.host}`);
        
        ws.onopen = () => {
          console.log('WebSocket connected');
          resolve();
        };
        
        ws.onerror = (err) => {
          console.error('WebSocket error:', err);
          reject(err);
        };
        
        ws.onclose = () => {
          console.log('WebSocket closed');
          if (isInCall) {
            showError('Verbinding verbroken, opnieuw verbinden...');
            setTimeout(connectWS, 2000);
          }
        };
        
        ws.onmessage = async (event) => {
          if (event.data instanceof Blob) {
            // Audio response - queue it for playback
            const audioUrl = URL.createObjectURL(event.data);
            audioQueue.push(audioUrl);
            
            // Start playing if not already
            if (!isPlayingQueue) {
              playNextInQueue();
            }
          } else {
            const msg = JSON.parse(event.data);
            console.log('Message:', msg);
            
            if (msg.type === 'transcript') {
              addMessage('user', msg.text);
            } else if (msg.type === 'acknowledgment') {
              // Quick acknowledgment - show it
              addMessage('assistant', msg.text);
            } else if (msg.type === 'response') {
              addMessage('assistant', msg.text);
            } else if (msg.type === 'hold_music') {
              // Handle hold music
              if (msg.action === 'start' && msg.url) {
                startHoldMusic(msg.url);
              } else if (msg.action === 'stop') {
                stopHoldMusic();
              }
            } else if (msg.type === 'status') {
              if (msg.message === 'Transcribing...') {
                setStatus('Verwerken...', 'processing');
                isProcessing = true;
              } else if (msg.message === 'Craby is thinking...') {
                setStatus('Craby denkt na...', 'processing');
              } else if (msg.message === 'Generating voice...' || msg.message === 'Formatting for voice...') {
                setStatus('Stem genereren...', 'processing');
              } else if (msg.message === 'No speech detected') {
                isProcessing = false;
                setStatus('Luisteren...', 'listening');
              } else if (msg.message === 'Ready') {
                isProcessing = false;
              }
            } else if (msg.type === 'error') {
              showError(msg.message);
              isProcessing = false;
              stopHoldMusic();
              setStatus('Luisteren...', 'listening');
            }
          }
        };
      });
    }
    
    // Audio queue playback
    async function playNextInQueue() {
      if (audioQueue.length === 0) {
        isPlayingQueue = false;
        isCrabySpeaking = false;
        avatar.className = 'call-avatar connected';
        
        // Resume listening after all audio done
        if (isInCall && !isMuted) {
          setStatus('Luisteren...', 'listening');
          if (vadInstance) vadInstance.start();
        }
        return;
      }
      
      isPlayingQueue = true;
      isCrabySpeaking = true;
      
      // Stop hold music when main audio starts
      stopHoldMusic();
      
      // Pause VAD while playing
      if (vadInstance) vadInstance.pause();
      
      avatar.className = 'call-avatar speaking';
      setStatus('Craby spreekt...', 'speaking');
      
      const audioUrl = audioQueue.shift();
      audioPlayer.src = audioUrl;
      // Ensure playback speed is applied
      audioPlayer.playbackRate = parseFloat(speedSlider.value);
      await audioPlayer.play();
    }
    
    // Hold music functions
    function startHoldMusic(url) {
      if (isHoldMusicPlaying) return;
      console.log('Starting hold music:', url);
      holdMusic.src = url;
      holdMusic.volume = 0.15; // Low volume background
      holdMusic.play().catch(e => console.log('Hold music blocked:', e));
      isHoldMusicPlaying = true;
      setStatus('Even geduld...', 'processing');
    }
    
    function stopHoldMusic() {
      if (!isHoldMusicPlaying) return;
      console.log('Stopping hold music');
      holdMusic.pause();
      holdMusic.currentTime = 0;
      isHoldMusicPlaying = false;
    }
    
    // Audio finished playing - play next in queue
    audioPlayer.onended = () => {
      playNextInQueue();
    };
    
    // Initialize VAD
    async function initVAD() {
      try {
        // Create audio context for visualizer
        audioContext = new AudioContext();
        
        vadInstance = await vad.MicVAD.new({
          onSpeechStart: () => {
            if (!isInCall || isMuted || isProcessing || isCrabySpeaking) return;
            console.log('Speech started');
            avatar.className = 'call-avatar connected';
            setStatus('Je spreekt...', 'listening');
          },
          onSpeechEnd: async (audio) => {
            if (!isInCall || isMuted || isProcessing || isCrabySpeaking) return;
            console.log('Speech ended, sending audio...');
            
            isProcessing = true;
            setStatus('Verwerken...', 'processing');
            
            // Convert Float32Array to WAV and send
            const wavBlob = float32ToWav(audio, 16000);
            ws.send(wavBlob);
          },
          onVADMisfire: () => {
            console.log('VAD misfire (background noise)');
          },
          positiveSpeechThreshold: 0.8,  // Higher = less sensitive
          negativeSpeechThreshold: 0.4,
          redemptionFrames: 8,
          minSpeechFrames: 5,
          preSpeechPadFrames: 5,
        });
        
        console.log('VAD initialized');
        loadingOverlay.classList.add('fade-out');
        
      } catch (err) {
        console.error('VAD init failed:', err);
        showError('Kon spraakherkenning niet laden: ' + err.message);
        loadingOverlay.classList.add('fade-out');
        
        // Fallback to simple volume-based detection
        initFallbackVAD();
      }
    }
    
    // Convert Float32Array to WAV blob
    function float32ToWav(float32Array, sampleRate) {
      const buffer = new ArrayBuffer(44 + float32Array.length * 2);
      const view = new DataView(buffer);
      
      // WAV header
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + float32Array.length * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, float32Array.length * 2, true);
      
      // Convert samples
      let offset = 44;
      for (let i = 0; i < float32Array.length; i++) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
      
      return new Blob([buffer], { type: 'audio/wav' });
    }
    
    // Fallback VAD (simple volume-based)
    async function initFallbackVAD() {
      console.log('Using fallback VAD');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        const source = audioContext.createMediaStreamSource(stream);
        source.connect(analyser);
        analyser.fftSize = 512;
        
        const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
        let audioChunks = [];
        let isRecording = false;
        let silenceTimer = null;
        
        const THRESHOLD = 25;
        const SILENCE_MS = 1200;
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) audioChunks.push(e.data);
        };
        
        mediaRecorder.onstop = () => {
          if (audioChunks.length > 0 && isInCall && !isMuted) {
            const blob = new Blob(audioChunks, { type: 'audio/webm' });
            ws.send(blob);
            isProcessing = true;
            setStatus('Verwerken...', 'processing');
          }
          audioChunks = [];
        };
        
        // VAD mock object
        vadInstance = {
          start: () => {
            const check = () => {
              if (!isInCall || isMuted || isCrabySpeaking) {
                requestAnimationFrame(check);
                return;
              }
              
              const data = new Uint8Array(analyser.frequencyBinCount);
              analyser.getByteFrequencyData(data);
              const avg = data.reduce((a, b) => a + b) / data.length;
              
              // Visualizer
              const volumes = Array.from(data.slice(0, 12)).map(v => v / 255);
              updateVisualizer(volumes, isCrabySpeaking);
              
              if (avg > THRESHOLD && !isProcessing && !isCrabySpeaking) {
                if (!isRecording) {
                  isRecording = true;
                  audioChunks = [];
                  mediaRecorder.start();
                  setStatus('Je spreekt...', 'listening');
                }
                clearTimeout(silenceTimer);
                silenceTimer = setTimeout(() => {
                  if (isRecording) {
                    isRecording = false;
                    mediaRecorder.stop();
                  }
                }, SILENCE_MS);
              }
              
              requestAnimationFrame(check);
            };
            check();
          },
          pause: () => {
            if (mediaRecorder.state === 'recording') {
              mediaRecorder.stop();
            }
          },
          destroy: () => {
            stream.getTracks().forEach(t => t.stop());
          }
        };
        
        loadingOverlay.classList.add('fade-out');
        
      } catch (err) {
        showError('Microfoon toegang geweigerd');
        loadingOverlay.classList.add('fade-out');
      }
    }
    
    // Start call
    async function startCall() {
      try {
        // Connect WebSocket first
        await connectWS();
        
        // Start VAD
        if (vadInstance) {
          vadInstance.start();
        } else {
          await initFallbackVAD();
          vadInstance.start();
        }
        
        isInCall = true;
        callStartTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
        
        // Update UI
        avatar.className = 'call-avatar connected';
        callType.textContent = 'Verbonden';
        callTimer.classList.add('visible');
        callActions.classList.add('hidden');
        inCallActions.classList.remove('hidden');
        setStatus('Luisteren...', 'listening');
        
        // Play connect sound (simple beep)
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = 440;
        gain.gain.value = 0.3;
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
        osc.stop(ctx.currentTime + 0.2);
        
      } catch (err) {
        showError('Kon niet verbinden: ' + err.message);
      }
    }
    
    // End call
    function endCall() {
      isInCall = false;
      isCrabySpeaking = false;
      isProcessing = false;
      isPlayingQueue = false;
      
      // Clear audio queue
      audioQueue = [];
      
      // Stop hold music
      stopHoldMusic();
      
      // Stop timer
      clearInterval(timerInterval);
      callStartTime = null;
      
      // Stop VAD
      if (vadInstance) {
        vadInstance.pause();
      }
      
      // Close WebSocket
      if (ws) {
        ws.close();
        ws = null;
      }
      
      // Stop any playing audio
      audioPlayer.pause();
      audioPlayer.src = '';
      
      // Play hangup sound
      const ctx = new AudioContext();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.frequency.value = 350;
      gain.gain.value = 0.3;
      osc.start();
      setTimeout(() => { osc.frequency.value = 440; }, 100);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
      osc.stop(ctx.currentTime + 0.3);
      
      // Update UI
      avatar.className = 'call-avatar';
      callType.textContent = 'Tik om te bellen';
      callTimer.classList.remove('visible');
      callTimer.textContent = '00:00';
      callActions.classList.remove('hidden');
      inCallActions.classList.add('hidden');
      setStatus('Gesprek be√´indigd', '');
      updateVisualizer(Array(12).fill(0));
      
      setTimeout(() => {
        setStatus('Klaar om te bellen', '');
      }, 2000);
    }
    
    // Toggle mute
    function toggleMute() {
      isMuted = !isMuted;
      btnMute.classList.toggle('muted', isMuted);
      btnMute.textContent = isMuted ? 'üîá' : 'üé§';
      
      if (isMuted) {
        setStatus('Gedempt', 'processing');
        if (vadInstance) vadInstance.pause();
      } else {
        setStatus('Luisteren...', 'listening');
        if (vadInstance && !isCrabySpeaking) vadInstance.start();
      }
    }
    
    // Event listeners
    btnCall.onclick = startCall;
    btnHangup.onclick = endCall;
    btnMute.onclick = toggleMute;
    
    // Initialize
    async function init() {
      try {
        // Try to init advanced VAD
        if (window.vad && window.vad.MicVAD) {
          await initVAD();
        } else {
          console.log('VAD library not loaded, using fallback');
          loadingOverlay.classList.add('fade-out');
        }
      } catch (err) {
        console.error('Init error:', err);
        loadingOverlay.classList.add('fade-out');
      }
    }
    
    init();
  </script>
</body>
</html>
